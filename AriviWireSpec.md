

# ARIVI Wire Specification 

## 1) Handshake Frame

This type of frame contains handshake of the connection.

 1. **HANDSHAKE_INIT:** It follows an integrated handshake pattern where key exchange and version/ encryption negotiation happens simultaneously.  Handshake-Init contains the following fields which are together encrypted using the remote party's public key. 
as part of negotiation,
	 - supported protocol version list 
	 - supported encryption mode list
	 - unique session id 

	and for key-exchange,
	  -  public key 
	  - ephemeral public 
	
	The opcode field to be set to Handshake-Init.
    The recipient computes a shared secret key for subsequent encrypted communication using the below: 
    - freshly generated ephemeral key pair
    - received  remote-public-key  
    
2.  **HANDSHAKE_ACK:**  
    The Ack frame contains the following fileds which will be encrypted using the remote party's (initiator's) public key.
     - public key
     - ephemeral public
     - negotiated  protocol version 
     - negotiated  encryption mode

	The opcode field to be set to Handshake-Ack.
    
---

## 2) Regular Frame

This is type of frame is used for regular messages containing application data payload that is typically encrypted (negotiated during handshake) per the application's needs. 

---

## 3) Reset/Close Frame

This frame contains information about the closing/ resetting connection, If opcode field is RESET then session of the connection resets, if it is CLOSE then the connection closes

---
## 4) Error Frame


This frame contains information about the error in connection, the opcode of this type of frame is set to **ERROR** and the **ERROR Descriptor** field is present in this frame. 

---

### Version: \[1 Byte\]

Version of the Wire Spec this will be negotiated at the initial messages, Client and server will negotiated this by taking latest of common version, For Ex. Client has v1,v2 and Server has v1,v2,v3 then the communication version will be v2 , This field is 32 bit long.

---
### Opcode: \[1 Byte\]

 - **ERROR - 0x00**

Indicates an error processing a request. The Error descriptor of the message will contain an error code followed by a error message. Then, depending on the exception, more content may follow. The error codes are defined in along with their additional content if any
    
-   **HANDSHAKE_REQUEST 0x01**
This opcode indicates that the given frame is HANDSHAKE_REQUEST step (1 of 3) in message handshake.
    

-   **HANDSHAKE_RESPONSE 0x02**
This opcode indicates that the given frame is HANDSHAKE_RESPONSE step (2 of 3) in message handshake.
    
-   **HANDSHAKE_ACK - 0x03**
This opcode indicates that the given frame is HANDSHAKE_ACK step (3 of 3) in message handshake.
    
-   **Options 0x04**
Asks the server to return what service options are supported. The body of an OPTIONS message should be empty and the server will respond with a SUPPORTED message such as services Kademlia,Chord,Block

-   **Reset, 0x05**
Resets the connection session
    
-   **Close 0x06**
Terminates the current connection with the server
    
-   **Ping 0x07**
A Ping frame may serve either as a keepalive or as a means to verify that the remote endpoint is still alive.
    
-   **Pong 0x08**
A Pong frame sent in response to a Ping frame. A Pong frame may be sent unsolicited to serve an unidirectional heartbeat.  A response to an unsolicited Pong frame is not expected.
    
----

### Public Flags: \[1 Byte\]

-   **Fragmentation** : This bit is set for fragmented messages. Unfragmented messages will not have this bit set.
    
-   **Initiator:** This bit will be set to 1 if the Connection was initiated by this endpoint. Will be useful in maintain the counter/nonce exclusivity for certain symmetric encryption schemes like AES / Poly where unique nonce is needed.
    
-   **Encryption  Type (0 None,1 AES CTR, 2 PolyChaCha)**
	- This defines the encryption method used for encryption of payload , two bits is allocated for this

			00 - None

			01 - AES CTR Mode

			10 - ChaChaPoly


-   **Encoding:**
	- This field is used to represent the encoding used for the message it can be UTF-8,CBOR,JSON,Googleâ€™s Protocol Buffer, etc
    

  

-   **TransportType:**
	-  If this bit is set TCP otherwise UDP.

---

### SessionId  \[4 Bytes\] 

 - This is unique identifier which is generated by client using some random function. This is used to map negotiated protocol version,shared secret key used for encryption,negotiated encoding type of multiplexed service, public key of the other party.
 - We need to store key (sessionId) and value ( (protocolContext, port ,ip ,transport-type, encryption-format, app-encoding-type)) in sessionHashMap for further reference.

---
 
  

### Descriptor \[2 Bytes\]

 -  This is optional field in the frame. If opcode value is ERROR, then this field serves as an Error descriptor. 
 -  Else if the opcode value is SUPPORTED then this field will contain a list of supported Services. This field is not used for other opcodes.

---
  
  
  

### Message id: \[1 Byte\]  
- This field will be present only if fragmentation bit is set. All fragments of a given message will have the same message id.
  
---

### Fragment number \[1 or 2 Bytes\]
- If the first bit is 0, then the next 7 bits indicate the fragment number, fragment counting starts from 1.
- If the first bit is set to 1, then the next 15 bits indicate the fragment number.
- If the first 8 bits are zeroes, then this fragment is considered to be the final fragment.

---

### Payload marker \[1 Byte\]
- Service being multiplexed.

 ---
 
### Payload-Length \[3 Byte\] 

 -  This denote the length of message in payload field. This field size is 3 Bytes which gives 2^(3*8) bits = 2 MB max size of payload but actual size will be 500KB

  ---

### Header-MAC \[16 Byte\] 

 -  This denote the message authentication code for the 'header' contents which include all the above fields. This applies for Regular Frame only. It employs SHA-3 HMAC algorithm as below:
 - SHA3( SHA3(Header) || Shared Secret)

  ---
### Payload  \[Max 2MB, but actual 500KB\]

- This is the actual payload of the frame which can be of max size 2MB but actual size is 500KB in TCP, 50KB in UDP

---
